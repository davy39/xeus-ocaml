"use strict";(self.webpackChunkjupyterlab_commands_executor=self.webpackChunkjupyterlab_commands_executor||[]).push([[509],{509:(e,o,t)=>{t.r(o),t.d(o,{default:()=>n});const n={id:"jupyterlab-commands-executor:plugin",description:"A JupyterLab extension to execute UI commands from kernel comm messages.",autoStart:!0,requires:[t(722).INotebookTracker],activate:(e,o)=>{console.log("[CommExecutor] >>> ACTIVATE: Plugin (version INotebookTracker) is starting.");const t="jupyterlab-commands-executor",n=new Set,s=o=>{n.has(o.id)||(console.log(`[CommExecutor] >>> KERNEL: Attempting to register comm target on kernel ${o.id}`),o.registerCommTarget(t,(o,t)=>{console.log("[CommExecutor] >>> COMM: Comm channel opened by kernel!",{openMsg:t});const n=t.content.data,{command:s,args:c}=n;if(!s)return console.warn('[CommExecutor] >>> COMM: Received open message without a "command" field.'),void o.close();console.log(`[CommExecutor] >>> EXEC: Executing UI command from open message: '${s}'`,c||{}),e.commands.execute(s,c||{}).then(e=>{console.log(`[CommExecutor] >>> EXEC: Command '${s}' executed successfully.`),o.send({status:"success"})}).catch(e=>{console.error(`[CommExecutor] >>> EXEC: Error executing command '${s}':`,e),o.send({status:"error",error:e.message})}).finally(()=>{o.close()})}),n.add(o.id),console.log(`[CommExecutor] >>> KERNEL: Comm target "${t}" successfully registered for kernel: ${o.id}`),o.disposed.connect(()=>{console.log(`[CommExecutor] >>> KERNEL: Kernel ${o.id} disposed. Cleaning up.`),n.delete(o.id)}))};o.widgetAdded.connect((e,o)=>{console.log("[CommExecutor] >>> SIGNAL: widgetAdded fired."),(e=>{e.sessionContext.ready.then(()=>{console.log(`[CommExecutor] >>> NOTEBOOK: Session ready for ${e.context.path}`);const o=e.sessionContext.session?.kernel;o&&s(o)}),e.sessionContext.kernelChanged.connect((o,t)=>{t.newValue&&(console.log(`[CommExecutor] >>> NOTEBOOK: Kernel changed for ${e.context.path}`),s(t.newValue))})})(o)}),console.log("[CommExecutor] >>> ACTIVATE: Plugin activation finished.")}}}}]);